### 5.6.3 高级话题

#### 5.6.3.1 选择加密方法

在上面的示例代码中，我们展示了三种加密方法的实现示例，每种加密方法用于加密解密以及数据伪造的检测。 你可以使用“图 5.6-1”，“图 5.6-2”，根据你的应用粗略选择使用哪种加密方法。 另一方面，加密方法的更加精细的选择，需要更详细地比较各种方法的特征。 在下面我们考虑一些这样的比较。

用于加密和解密的密码学方法的比较

公钥密码术具有很高的处理成本，因此不适合大规模数据处理。但是，因为用于加密和解密的密钥不同，所以仅仅在应用侧处理公钥（即，只执行加密），并且在不同（安全）位置执行解密的情况下，管理密钥相对容易。共享密钥加密是一种通用的加密方案，但限制很少，但在这种情况下，相同的密钥用于加密和解密，因此有必要将密钥安全地存储在应用中，从而使密钥管理变得困难。基于密码的密钥系统（基于密码的共享密钥系统）通过用户指定的密码生成密钥，避免了在设备中存储密钥相关的密码的需求。此方法用于仅仅保护用户资产，但不保护应用资产的应用。由于加密强度取决于密码强度，因此有必要选择密码，其复杂度与要保护的资产价值成比例增长。请参阅“5.6.2.6 采取措施来增加密码强度（推荐）”。

表 5.6-4 用于加密和解密的密码学方法的比较

| 条目/加密方法 | 公钥 | 共享密钥 | 基于密码 |
| --- | --- | --- | --- |
| 处理大规模数据 | 否（开销太大） | OK | OK |
| 保护应用（或服务）资产 | OK | OK | 否（允许用户窃取） |
| 保护用户资产 | OK | OK | OK |
| 加密强度 | 取决于密钥长度 |  取决于密钥长度 | 取决于密码强度，盐和哈希重复次数 |
| 密钥存储 | 简单（仅公钥） | 困难 | 简单 |
| 由应用执行的过程 | 加密（解密在服务器或其它地方完成） | 加密和解密 | 加密和解密 |

用于检测数据伪造的密码学方法的比较

这里的比较与上面讨论的加密和解密类似，除了与数据大小对应的条目不再相关。

表 5.6-5 用于检测数据伪造的密码学方法的比较

| 条目/加密方法 | 公钥 | 共享密钥 | 基于密码 |
| --- | --- | --- | --- |
| 保护应用（或服务）资产 | OK | OK | 否（允许用户伪造） |
| 保护用户资产 | OK | OK | OK |
| 加密强度 | 取决于密钥长度 |  取决于密钥长度 | 取决于密码强度，盐和哈希重复次数 |
| 密钥存储 | 简单（仅公钥） | 困难，请参考“5.6.3.4 保护密钥” | 简单 |
| 由应用执行的过程 | 签名验证（签名在服务器或其它地方完成） | MAC 计算和验证 | MAC 计算和验证 |

MAC：消息认证代码


请注意，这些准则主要关注被视为低级或中级资产的资产保护，根据“3.1.3 资产分类和保护对策”一节中讨论的分类。 由于使用加密涉及的问题，比其他预防性措施（如访问控制）更多，如密钥存储问题，因此只有资产不能在 Android 操作系统安全模式下有效保护时，才应该考虑加密。

#### 5.6.3.2 随机数的生成

使用加密技术时，选择强加密算法和加密模式，以及足够长的密钥，来确保应用和服务处理的数据的安全性，这非常重要。 然而，即使所有这些选择都做得适当，当形成安全协议关键的密钥被泄漏或猜测时，所使用的算法所保证的安全强度立即下降为零。

即使对于在AES和类似协议下，用于共享密钥加密的初始向量（IV），或者用于基于密码的加密的盐，较大偏差也可以使第三方轻松发起攻击，从而增加数据泄漏或污染的风险 。 为了防止这种情况，有必要以第三方难以猜测它们的值的方式，产生密钥和 IV，而随机数在确保这一必要实现的方面，起着非常重要的作用。 产生随机数的设备称为随机数生成器。 尽管硬件随机数生成器（RNG）可能使用传感器或其他设备，通过测量无法预测或再现的自然现象来产生随机数，但更常见的是用软件实现的随机数生成器，称为伪随机数生成器（PRNG）。

在Android应用程序中，可以通过`SecureRandom`类生成用于加密的足够安全的随机数。 `SecureRandom`类的功能由一个称为`Provider`的实现提供。 多个供应器（实现）可以在内部存在，并且如果没有明确指定供应器，则会选择默认供应器。 出于这个原因，也可以在不知道供应器存在的情况下，使用`SecureRandom`来实现。 在下面,我们提供的例子演示了如何使用`SecureRandom`。 

请注意，根据 Android 版本的不同，`SecureRandom`可能存在一些缺陷，需要在实施中采取预防措施。 请参阅“5.6.3.3 防止随机数生成器中的漏洞的措施”。

使用`SecureRandom`（默认实现）

```java
import java.security.SecureRandom;

[...]

SecureRandom random = new SecureRandom();
byte[] randomBuf = new byte [128];
random.nextBytes(randomBuf);

[...]
```

使用`SecureRandom`（明确的特定算法）

```java
import java.security.SecureRandom;

[...]

SecureRandom random = SecureRandom.getInstance("SHA1PRNG");
byte[] randomBuf = new byte [128];
random.nextBytes(randomBuf);

[...]
```

使用`SecureRandom`（明确的特定实现（供应器））

```java
import java.security.SecureRandom;

[...]

SecureRandom random = SecureRandom.getInstance("SHA1PRNG", “Crypto”);
byte[] randomBuf = new byte [128];
random.nextBytes(randomBuf);

[...]
```

程序中发现的伪随机数发生器，例如`SecureRandom`，通常基于一些基本过程来操作，如“图 5.6-3 伪随机数发生器的内部过程”中所述。 输入一个随机数种子来初始化内部状态；此后，每次生成随机数时更新内部状态，从而允许生成随机数序列。

随机数种子

种子在伪随机数发生器（PRNG）中起着非常重要的作用。 如上所述，PRNG 必须通过指定种子来初始化。 此后，用于生成随机数的过程是确定性算法，因此如果指定相同的种子，则会得到相同的随机数序列。 这意味着如果第三方获得（即窃听）或猜测 PRNG 的种子，他可以产生相同的随机数序列，从而破坏随机数提供的机密性和完整性属性。

出于这个原因，随机数生成器的种子本身就是一个高度机密的信息 - 而且必须以无法预测或猜测的方式来选择。 例如，不应使用时间信息或设备特定数据（例如 MAC 地址，IMEI 或 Android ID）来构建 RNG 种子。 在许多 Android 设备上，`/dev/urandom`或`/dev/random`可用，Android 提供的`SecureRandom`默认实现使用这些设备文件，来确定随机数生成器的种子。 就机密性而言，只要 RNG 种子仅存在于内存中，除获得 root 权限的恶意软件工具外，几乎没有由第三方发现的风险。 如果您需要实现，即使在已 root 的设备上仍然有效的安全措施，请咨询安全设计和实现方面的专家。

伪随机数生成器的内部状态

伪随机数发生器的内部状态由种子初始化，然后在每次生成随机数时更新。 就像由相同种子初始化的 PRNG 一样，具有相同内部状态的两个 PRNG 随后将产生完全相同的随机数序列。 因此，保护内部状态免受第三方窃听也很重要。 但是，由于内部状态存在于内存中，除了拥有 root 访问权的恶意软件工具外，几乎没有发现任何第三方的风险。 如果您需要实现，即使在已 root 的设备上仍然有效的安全措施，请咨询安全设计和实现方面的专家。

#### 5.6.3.3 防范随机数生成器中的漏洞的措施


在 Android 4.3.x 及更早版本中发现，`SecureRandom`的`Crypto`供应器实现拥有内部状态熵（随机性）不足的缺陷。 特别是在 Android 4.1.x 及更早版本中，`Crypto`供应器是`SecureRandom`的唯一可用实现，因此大多数直接或间接使用`SecureRandom`的应用程序都受此漏洞影响。 同样，Android 4.2 和更高版本中，作为`SecureRandom`的默认实现而提供的`AndroidOpenSSL`供应器拥有这个缺陷，由`OpenSSL`使用的作为随机数种子的大部分数据在应用程序之间共享（Android 4.2.x-4.3 .x），产生了一个漏洞，任何应用程序都可以轻松预测其他应用程序生成的随机数。 下表详细说明了各种 Android OS 版本中存在的漏洞的影响。

表 5.6-6 Android操作系统版本和受到每个漏洞的影响的功能

| Android OS/漏洞 | `SecureRandom`的`Crypto`供应器实现的内部状态熵不足 | 可以猜测其他程序中`OpenSSL`所使用的随机数 |
| --- | --- | --- |
|  4.1.x 及之前 | `SecureRandom`的默认实现，`Crypto`供应器的显式使用，由`Cipher`类提供的加密功能，HTTPS 通信功能等 | 无影响 |
| 4.2 - 4.3.x | 使用明确标识的`Crypto`供应器 | `SecureRandom`的默认实现，Android OpenSSL 供应器的显式使用，`OpenSSL`提供的随机数生成功能的直接使用，由`Cipher`类提供的加密功能，HTTPS 通信功能等 |
| 4.4 及之后 | 无影响 | 无影响 |

